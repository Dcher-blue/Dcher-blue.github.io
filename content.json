{"meta":{"title":"Nap lovers","subtitle":"漫天星河不及你","description":"","author":"蓝色","url":"https://dcher-blue.github.io","root":"/dcher-blue.github.io/"},"pages":[{"title":"categories","date":"2020-05-04T02:40:13.000Z","updated":"2020-11-29T08:09:08.752Z","comments":true,"path":"categories/index.html","permalink":"https://dcher-blue.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-05-04T02:40:16.000Z","updated":"2020-11-29T08:10:09.746Z","comments":true,"path":"contact/index.html","permalink":"https://dcher-blue.github.io/contact/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-04T02:40:15.000Z","updated":"2020-11-29T08:09:50.309Z","comments":true,"path":"about/index.html","permalink":"https://dcher-blue.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-04T02:40:14.000Z","updated":"2020-11-29T08:09:30.319Z","comments":true,"path":"tags/index.html","permalink":"https://dcher-blue.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-05-04T02:40:17.000Z","updated":"2020-12-01T13:23:26.389Z","comments":true,"path":"friends/index.html","permalink":"https://dcher-blue.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"链表","slug":"链表","date":"2021-04-15T10:08:55.000Z","updated":"2021-04-19T04:25:21.839Z","comments":true,"path":"2021/04/15/链表/","link":"","permalink":"https://dcher-blue.github.io/2021/04/15/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表什么是链表链表是一种线性表，它不像是顺序表那样连续的存储数据，而是在每一个节点里存放下一个节点的地址 为什么需要链表顺序表的构建需要提前清楚数据大小来申请连续的空间，但是在进行扩充固定时候又需要进行数据的搬迁，所以使用起来不是很灵魂。而链表的结构可以充分利用计算机内存空间，实现灵活的内存动态管理 ps: 需要注意的是链表必须有一个头结点来定位，最后一个节点为尾结点，尾结点所指向的是空 单链表的实现节点的实现class Node: &quot;&quot;&quot;节点&quot;&quot;&quot; def __init__(self, elem): self.elem = elem self.next = None class Link_list(Node): &quot;&quot;&quot;单链表&quot;&quot;&quot; def __init__(self, node=None): self._head = node def is_empty(self): &quot;&quot;&quot;链表是否空&quot;&quot;&quot; return self._head == None def length(self): &quot;&quot;&quot;链表长度&quot;&quot;&quot;&quot; cur = self._head # 游标 count = 0 #记录数量 while cur != None: count += 1 cur = cur.next return count def travel(self): &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot; cur = self._head while cur != None: print(cur.elem) cur = cur.next def add(self, item): &quot;&quot;&quot;链表头部添加元素&quot;&quot;&quot; def append(self, item): &quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot; node = Node(item) if self.is_empty(): self._head = node else: cur = self._head while cur.next != None: cur = cur.next cur.next = node def insert(self, pos, item): &quot;&quot;&quot;指定位置添加&quot;&quot;&quot; def remove(self, item): &quot;&quot;&quot;删除节点&quot;&quot;&quot; def search(self, item): &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://dcher-blue.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"python_x2","slug":"python_x2","date":"2021-03-22T02:39:22.000Z","updated":"2021-03-22T03:25:30.828Z","comments":true,"path":"2021/03/22/python_x2/","link":"","permalink":"https://dcher-blue.github.io/2021/03/22/python_x2/","excerpt":"","text":"eval()和exec()eval()和exec()功能有些相似，都可以执行一个字符串形式的python代码，相当于一个python解释器，区别在于eval()执行完要返回结果，而exec()执行完不返回结果。 eval()该函数用来计算指定表达式的值，需要注意的是eval不支持任何赋值操作且不能是复杂的代码逻辑，和lambda函数有点相似 函数定义eval(expression, globals=None, locals=None) 参数说明1 experssion:必选参数，可以是字符串，也可以是一个任意的code对象实例（可以通过compile函数创建）。如果它是一个字符串，它会被当作一个（使用globals和locals参数作为全局和本地命名空间的）Python表达式进行分析和解释 2 globals：可选参数，表示全局命名空间（存放全局变量），如果被提供，则必须是一个字典对象 3 locals：可选参数，表示当前局部命名空间（存放局部变量），如果被提供，可以是任何映射对象。如果该参数被忽略，那么它将会取与globals相同的值 ps:如果globals与locals都被忽略，那么它们将取eval()函数被调用环境下的全局命名空间和局部命名空间 实例12345678910111213x &#x3D; 10def func(): y &#x3D; 20 a &#x3D; eval(&#39;x + y&#39;) print(&#39;a: &#39;, a) b &#x3D; eval(&#39;x + y&#39;, &#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;) print(&#39;b: &#39;, b) c &#x3D; eval(&#39;x + y&#39;, &#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;y&#39;: 3, &#39;z&#39;: 4&#125;) print(&#39;c: &#39;, c) d &#x3D; eval(&#39;print(x, y)&#39;) print(&#39;d: &#39;, d)func() 输出结果:a: 30b: 3c: 410 20d: None 由上面的例子可以看出，首先对于变量a，eval的两个可选参数都被忽略了，所以变量x和变量y都用的是eval函数被调用环境下的作用域中的变量:x = 10, y = 20对于变量b来说，eval函数提供了globals参数忽略了locals参数，因此locals会取globals参数的值：x = 1, y = 2 对于变量c，eval函数的两个可选参数都被提供了，那么eval函数会先从全部作用域globals中找到变量x，从局部作用域locals中找到变量y: x = 1, y = 3 而对于变量d来说，print函数没有结果，因此返回了一个None,这就是eval函数的简单应用 exec()用以动态执行python代码，可以执行相对较复杂的代码 函数定义exec(object[, globals[, locals]]) 参数说明1 必选参数，表示需要被指定的Python代码。它必须是字符串或code对象。如果object是一个字符串，该字符串会先被解析为一组Python语句，然后在执行（除非发生语法错误）。如果object是一个code对象，那么它只是被简单的执行2 可选参数，同eval函数3 可选参数，同eval函数4 需要注意的是exec函数的返回值永远都是None，而eval函数可以有返回值 实例例1: 12345678910111213x &#x3D; 10def func(): y &#x3D; 20 a &#x3D; exec(&#39;x + y&#39;) print(&#39;a: &#39;, a) b &#x3D; exec(&#39;x + y&#39;, &#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;) print(&#39;b: &#39;, b) c &#x3D; exec(&#39;x + y&#39;, &#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;y&#39;: 3, &#39;z&#39;: 4&#125;) print(&#39;c: &#39;, c) d &#x3D; exec(&#39;print(x, y)&#39;) print(&#39;d: &#39;, d)func() 输出结果:a: Noneb: Nonec: None10 20d: None结果是显而易见的，因为exec函数的返回值永远为None 例2： 123456789101112x &#x3D; 10expr &#x3D; &quot;&quot;&quot;z &#x3D; 30sum &#x3D; x + y + zprint(sum)&quot;&quot;&quot;def func(): y &#x3D; 20 exec(expr) exec(expr, &#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;) exec(expr, &#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;y&#39;: 3, &#39;z&#39;: 4&#125;)func() 输出结果:603334 对于前两个数值应该不需要想，关于最后一个输出的34，首先可以看出：x = 1, y = 3是肯定没什么问题的，争议就在z的取值为什么是30而不是4，梳理一下代码的执行过程就好了如下: 123456789x &#x3D; 1y &#x3D; 2def func(): y &#x3D; 3 z &#x3D; 4 z &#x3D; 30 sum &#x3D; x + y + z print(sum)func() 因此最后得出的结果应是34","categories":[],"tags":[{"name":"python_def","slug":"python-def","permalink":"https://dcher-blue.github.io/tags/python-def/"}]},{"title":"python_pygame_1","slug":"python_pygame_1","date":"2021-03-20T08:26:44.000Z","updated":"2021-03-20T14:51:05.963Z","comments":true,"path":"2021/03/20/python_pygame_1/","link":"","permalink":"https://dcher-blue.github.io/2021/03/20/python_pygame_1/","excerpt":"","text":"pygame的display模块pygame.display是Pygame中用于控制窗口和屏幕显示的模块 pygame.display.set_mode()用以初始化一个准备显示的窗口或屏幕，set_mode(size=(0,0), flage=0, depth=0, display=0)-&gt;Surface1 size参数如果未设置就默认为(0,0)那么创建的Surface将具有与当前屏幕分辨率相同的大小。如果只有宽度或高度设置为0，那么Surface的对应参数将与屏幕分辨率相同 pygame.display.set_caption()这个方法是用以设置当前窗口标题, set_caption(title,icontitle=None)-&gt;None，如果要获得显示Surface的标题和图标(这些值通常都是相同的)，可以使用get_caption()方法。 pygame.display.set_icon()1 设置系统用来表示显示窗口的运行时的图标。所有窗口默认为窗口图标的简单Pygame徽标2 需要注意的是某些系统不允许窗口图标在显示后更改。此函数可以在set_mode()方法前调用，以便在设置显示模式之前创建图标 pygame.mixer.music在pygame中控制音频流的模块 pygame.mixer.music.get_busy()用以检查音乐是否正在播放，返回值是一个bool类型 如果返回True则正在播放，相反音乐空闲，需要注意的是即使音乐暂停也会返回True pygame.mixer.music.play() 开始播放已加载的音乐流, play(loops=0, start=0.0, fade_ms = 0) 1 loop(int)-- 重复音乐的次数，需要注意的是设置为-1可使音乐不确定地重复2 start(float)-- 音乐开始播放的位置，起始位置取决于播放的音乐格式：MP3和OGG使用该位置为时间(秒)3 fade_ms(int)-- 使音乐在给定时间内开始以0音量播放并淡入到最大音量 music模块方法的简介pygame.mixer.music.load() —— 载入一个音乐文件用于播放 pygame.mixer.music.rewind() —— 重新开始播放音乐 pygame.mixer.music.stop() —— 结束音乐播放 pygame.mixer.music.pause() —— 暂停音乐播放 pygame.mixer.music.unpause() —— 恢复音乐播放 pygame.mixer.music.fadeout() —— 淡出的效果结束音乐播放 pygame.mixer.music.set_volume() —— 设置音量 pygame.mixer.music.get_volume() —— 获取音量 pygame.mixer.music.set_pos() —— 设置播放的位置 pygame.mixer.music.get_pos() —— 获取播放的位置 pygame.mixer.music.queue() —— 将一个音乐文件放入队列中，并排在当前播放的音乐之后 pygame.mixer.music.set_endevent() —— 当播放结束时发出一个事件 pygame.mixer.music.get_endevent() —— 获取播放结束时发送的事件 pygame.mixer.Sound可以从文件或缓冲区对象中创建新的声音对象，参考Sound(filename)","categories":[],"tags":[{"name":"pygame","slug":"pygame","permalink":"https://dcher-blue.github.io/tags/pygame/"}]},{"title":"python_pygame","slug":"python_pygame","date":"2021-03-05T12:26:45.000Z","updated":"2021-03-20T08:27:42.845Z","comments":true,"path":"2021/03/05/python_pygame/","link":"","permalink":"https://dcher-blue.github.io/2021/03/05/python_pygame/","excerpt":"","text":"对图像进行翻转，缩放，旋转 transform模块的使用翻转pygame.transform.flip(Surface, xbool, ybool)1 xbool =&gt; True 为水平翻转2 ybool =&gt; True 为垂直翻转3 return Surface 缩放pygame.transform.scale(Surface, (width, height), DestSurface = None)1 (width, height): 缩放的大小2 returnSurface 旋转pygame.transform.rotate(Surface, angle)1 angle: 旋转角度2 return Surface pygame的init()init()是做什么的在python的面向对象中有__init__，其实在Pygame这个特殊的python模块中的init()与前者作用差不多:初始化在使用pygame这个模块以前，需要检查一次这个模块是否完整，能不能提供正常的方法，而这个检查的动作就是init() init()检查了什么我在命令行中执行了下面这小段代码 123import pygamepygame.init() 他却给我返回了一个元组(7,0),在查阅了官方文档以后,大致了解了`Initialize all imported pygame modules. No exceptions will be raised if a module fails, but the total number if successful and failed inits will be returned as a tuple. You can always initialize individual modules manually, but pygame.init() is a convenient way to get everything started. The init() functions for individual modules will raise exceptions when they fail. You may want to initialize the different modules separately to speed up your program or to not use things your game does not. It is safe to call this init() more than once: repeated calls will have no effect. This is true even if you have pygame.quit() all the modules.初始化所有导入的pygame模块。如果模块失败，将不会引发异常，但如果成功和失败的inits总数将作为元组返回。您总是可以手动初始化单个模块，但是pygame.init()是一种启动一切的方便方法。单个模块的init()函数在失败时会引发异常。 你可能想要分别初始化不同的模块来加速你的程序，或者不使用你的游戏没有的东西。 多次调用此init()是安全的:重复调用不会有任何效果。即使您拥有pygame.quit()所有模块，也是如此。`","categories":[],"tags":[{"name":"pygame","slug":"pygame","permalink":"https://dcher-blue.github.io/tags/pygame/"}]},{"title":"python_dict","slug":"python_x1","date":"2021-03-01T11:03:10.000Z","updated":"2021-03-30T11:26:35.522Z","comments":true,"path":"2021/03/01/python_x1/","link":"","permalink":"https://dcher-blue.github.io/2021/03/01/python_x1/","excerpt":"","text":"什么是字典?以键值对的形式进行存放，格式是{key:value},同样的key必须是immutable的对象，每个key都对应一个value，如下所示:score = &#123;&#39;zs&#39;:99, &#39;ls&#39;:98, &#39;ww&#39;:97&#125; 字典的创建1234s &#x3D; &#123;&#39;ls&#39;:99, &#39;zs&#39;:98, &#39;ww&#39;:100&#125;s &#x3D; dict()s &#x3D; &#123;&#125;s &#x3D; dict([&#39;ls&#39;,99], [&#39;zs&#39;,98]) 以上是创建字典的几种方式，需要注意的如果想把其他对象转换成dict那么该对象必须是包含成对的数据的iterable 123names &#x3D; [&#39;zs&#39;, &#39;ls&#39;, &#39;ww&#39;]scores &#x3D; [99, 98, 100]s &#x3D; dict(zip(names, scores)) 输出:{‘zs’: 99, ‘ls’: 98, ‘ww’: 100} 如上所示，如果有两组数据也可以使用zip方法来合并两组数据组成字典 如果只有了key却没有value那么可以使用fromkeys方法来生成一个value为None的字典s = dict.fromkeys(names) 字典的增加和删除123456names &#x3D; &#123;&#39;ls&#39;:98&#125;names[&#39;ww&#39;] &#x3D; 97 #增加数据del names[&#39;ls&#39;] #删除数据names.pop(&#39;ls&#39;) #使用pop删除(提取)names.poitem() #随机删除names.clear() # 清空 字典的更改和查找直接通过key来更改names[&#39;ls&#39;] = 99查找:①names[&#39;ls&#39;]直接通过key来访问value②names.get(&#39;ls&#39;)使用get方法来访问，如果不存在会返回一个None可以为字典中不存在的数据设置一个默认值，只要访问这个key就会返回这个默认值names.setdefault(&#39;lg&#39;,&#39;yeah&#39;) 字典的操作字典的遍历可以使用for循环直接遍历，但是需要注意的是字典是键值对访问的是key而不是value如果想要同时访问value需要使用以下方式: 12for k in names: print(k, names[k]) 可以使用keys方法来访问dict中所有的key值，也可以使用values来访问所有values，甚至可以使用items来将字典转换成列表，如下所示 12names &#x3D; &#123;&#39;ls&#39;:99,&#39;ww&#39;:97&#125;print(names.items()) 输出:dict_items([(‘ls’, 99), (‘ww’, 97)]) 字典的排序dict按照key来排序12names &#x3D; &#123;&#39;ls&#39;:99, &#39;ww&#39;:97, &#39;zs&#39;:100&#125;s &#x3D; &#123;k:v for k,v in sorted(names.items())&#125; 如上所示，是按照了key来排序，首先通过items将dict转换成一个列表的形式，然后使用sorted来进行排序生成一个新的列表，最后用k，v两个参数提取出列表中的key和value生成一个新字典 dict按照value来排序1234names &#x3D; &#123;&#39;ls&#39;:99, &#39;ww&#39;:97, &#39;zs&#39;:140&#125;s &#x3D; sorted(names.items(), key&#x3D;lambda n:n[1])g &#x3D; &#123;k:v for k,v in s&#125;print(g) 和按照key来排序的方式相似，首先想要排序那么就要使用itmes方法来将字典转换为一个可排序的list，然后通过sorted方法进行排序，最后生成一个新的dict 字典的复制字典也可以使用copy进行复制,需要注意的是这里使用copy是生成了一个新字典，地址不同 update1234names &#x3D; &#123;&#39;ls&#39;:99, &#39;ww&#39;:97, &#39;zs&#39;:140&#125;s &#x3D; &#123;&#39;sf&#39;:99, &#39;zc&#39;:98, &#39;jh&#39;:100, &#39;zs&#39;:150&#125;s.update(names)print(s) 输出:&#123;&#39;sf&#39;: 99, &#39;zc&#39;: 98, &#39;jh&#39;: 100, &#39;zs&#39;: 140, &#39;ls&#39;: 99, &#39;ww&#39;: 97&#125; 如上所示，update方法是将一个字典内所有内容全部传入另一个字典，如果要传入的字典中有相同key那么会将其覆盖","categories":[],"tags":[{"name":"python_ds","slug":"python-ds","permalink":"https://dcher-blue.github.io/tags/python-ds/"}]},{"title":"python_set","slug":"python_x","date":"2021-03-01T08:56:06.000Z","updated":"2021-03-30T11:26:46.081Z","comments":true,"path":"2021/03/01/python_x/","link":"","permalink":"https://dcher-blue.github.io/2021/03/01/python_x/","excerpt":"","text":"什么是setset不能重复，不分先后，只能加入immutable的内容 12names &#x3D; &#123;&#39;zs&#39;, &#39;lisi&#39;, &#39;zs&#39;&#125;print(name) 输出:{‘lisi’, ‘zs’} 这个例子显示出了set的前两个特性，第三个特性举个简单的例子如果再上述集合中加入了一个list[3,4]那么最后输出就会报错，因为list是可变的 集合的创建123names &#x3D; set&#123;&#125;names &#x3D; &#123;1,2,3,4,5&#125;names &#x3D; set([4,5,6]) 上述是几种集合建立的方式，需要注意的是第三种将其他转化为集合只能转化iterable的对象 集合的增加12names &#x3D; &#123;3,4&#125;names.add(&#39;5&#39;) 集合的增加很简单直接使用add方法直接添加元素就行. 集合的删除1234names &#x3D; &#123;3,4,5&#125;names.remove(&#39;3&#39;)names.discard(&#39;4&#39;)names.clear() 上述例子中有三种删除方式，使用remove可以删除但是如果不存在删除元素会报错，而discard有就删除，没有就什么都不会发生，clear则是清空 集合的查询集合的查询也是使用in和not in来查询，如下： 12names &#x3D; &#123;3,4,5&#125;print(6 not in names) 还有pop也可以用来查询，其实不如说是提取出一个元素 集合的操作几种集合的操作很早就学过了比如并，交等。如下所示: 123456789s1 &#x3D; &#123;1,2,3,4,5&#125;s2 &#x3D; &#123;2,4,5,6&#125;s3 &#x3D; s1 | s2 #∪s3 &#x3D; s1.union(s2) #∪s3 &#x3D; s1 &amp; s2 #∩s3 &#x3D; s1.intersection(s2)s3 &#x3D; s1 - s2s3 &#x3D; s1 ^ s2 #只在s1或者s2中print(s1.issuperset(s2)) # 比较 或者使用s1 &gt; s2也可以 除了以上操作以外还有复制操作: 12names &#x3D; &#123;1,2,3&#125;s &#x3D; names.copy() 注意使用copy复制的时候其实只是复制了地址，指向的是同一个对象 frozenset这是一种特殊的set类型，是不可以改变的","categories":[],"tags":[{"name":"python_ds","slug":"python-ds","permalink":"https://dcher-blue.github.io/tags/python-ds/"}]},{"title":"python_str","slug":"python_9","date":"2021-02-28T11:20:08.000Z","updated":"2021-03-30T11:27:01.453Z","comments":true,"path":"2021/02/28/python_9/","link":"","permalink":"https://dcher-blue.github.io/2021/02/28/python_9/","excerpt":"","text":"什么是字符串字符串是一个字符序列(sequence), 基于utf-8编码 字符串的创建123zs &#x3D; &#39;张三&#39;ls &#x3D; &quot;李四&quot;ww &#x3D; &#39;&#39;&#39;王五&#39;&#39;&#39; 在python中单引号和双引号区别不大，可以互相嵌套，如果使用三引号那么引号内的内容可以随意 字符串的拼接字符串也是immutable，但是字符串可以通过切片进行’更改’,也就是拼接，并且同一个字符串在系统中只有一个 字符串的查询通过下标来访问12nums &#x3D; &#39;12345&#39;print(nums[1]) 和列表元组一样直接通过下标来访问，包括in not in也都可以在字符串中使用,is和is not 和in not in用处差不多 都会返回一个True或者False 判定字符串的开始和结尾,下标开始print(nums.startswith(‘1’)) 结尾print(nums.endwith(‘5’)) 下标print(nums.index(‘3’)) 格式化输出12name &#x3D; &#39;zhangsan&#39;print(f&#39;hello,&#123;name&#125;&#39;) 已经学习过了卜多写了 字符串的拆分与合并字符串的拆分123names &#x3D; &#39;张三，李四，王五&#39;for n in names.split(&#39;，&#39;): print(n) 可以使用split方法来规定分隔的字符来分割字符串 字符串的合并123h &#x3D; &#39; hello &#39;names &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]print(h.join(names)) 输出:张三 hello 李四 hello 王五 如上例使用了join方法来进行h和names字符串的合并，需要注意的是如果这里names没有写成列表的形式而是变成了一个字符串那么就会出现每个字符之间都会出现一个’hello’的情况 字符串的查找12name &#x3D; &#39;今天是第一一一一一一天&#39;print(name.count(&#39;一&#39;)) 输出:6可以使用count方法来统计某个字符的出现次数 字符串改变大小写1234names &#x3D; &#39;zhang san is good boy&#39;name &#x3D; &#39;zhangsan&#39;print(names.title())print(name.title()) 输出:Zhang San Is Good BoyZhangsan 如上，如果一段字母字符串没有用不同类型的字符分隔开那么使用title方法只会改变起始的大小写，分隔开了则会改变每次分隔开的起始大小写，还有以下几种capitalize方法可以大写字符串中第一个字符upper方法是用来大写所有字符串lower方法使用来小写所有字符串swapcase方法是用来转换大小写 字符串去空格1234names &#x3D; &#39; wangwu &#39;print(names.strip())print(names.lstrip())print(names.rstrip()) 输出:wangwuwangwu wangwu 如上所示strip是一个去空格的方法 字符串的替换12names &#x3D; &#39;今天是第一一一一一一天&#39;print(names.replace(&#39;一&#39;,&#39;二&#39;)) replace方法是用来替换字符串中的字符的","categories":[],"tags":[{"name":"python_ds","slug":"python-ds","permalink":"https://dcher-blue.github.io/tags/python-ds/"}]},{"title":"python_tuple","slug":"python_8","date":"2021-02-28T10:59:00.000Z","updated":"2021-03-30T11:27:08.036Z","comments":true,"path":"2021/02/28/python_8/","link":"","permalink":"https://dcher-blue.github.io/2021/02/28/python_8/","excerpt":"","text":"元组什么是元组元组是一个有序的，不可改的数据结构(immutable)l = [5,3,4] #listn = (5,3,4) #tuple 元组的优点:1.快 2.安全 3.元组可以被称为dict的key使用元组:1.传参的时候 2.其他不变的情况 元组-建立1234t1 &#x3D; (5,3,9)t2 &#x3D; tuple([4,7,2])t3 &#x3D; tuple(&#39;python&#39;)t4 &#x3D; tuple(1,) 这个例子中t1是直接建立了一个元组，t2和t3则是将列表和字符串转换成元组，t4这里要注意如果想要建立单个元素的元组不可以直接t = (5)如果使用了type会发现这时的t是int类型而不是元组，所以想建立单元素元组必须用上面这个方法 元组-查12t &#x3D; (5, 3, 4)print(t[1]) 直接进行按下标查询元组即可 元组-切片12t &#x3D; (5, 3, 4)s &#x3D; t[0:2] 切片的方法全部跟list相同","categories":[],"tags":[{"name":"python_ds","slug":"python-ds","permalink":"https://dcher-blue.github.io/tags/python-ds/"}]},{"title":"python_list","slug":"python_7","date":"2021-02-28T08:49:53.000Z","updated":"2021-03-30T11:27:25.501Z","comments":true,"path":"2021/02/28/python_7/","link":"","permalink":"https://dcher-blue.github.io/2021/02/28/python_7/","excerpt":"","text":"列表-修改元素123names &#x3D; [&#39;5&#39;, &#39;4&#39;, &#39;3&#39;]names[1] &#x3D; &#39;2&#39;print(names) 输出:[‘5’, ‘2’, ‘3’]可以直接通过列表的下标对列表中的元素进行修改，list保存的是实际对象的地址，修改只是指向了要修改对象的新地址 列表-查询元素123names &#x3D; [&#39;5&#39;, &#39;4&#39;, &#39;3&#39;]print(names[1])print(names.index(&#39;4&#39;)) 输出:41如果已知元素下标可以直接通过下标进行查询输出，如果已知元素，可以通过index方法来查询已知元素的下标，同样的如果为了防止下标越界情况的发生，可以使用in或not in方法 列表-元素遍历使用for来遍历列表123names &#x3D; [5, 4, 3]for n in names: print(&#39;yes, &#39;, n) 输出: yes, 5yes, 4yes, 3 enumerate函数来遍历123names &#x3D; [5, 4, 3]for index,n in enumerate(names): print(f&#39;num:&#123;index&#125; is &#123;n&#125;&#39;) 输出:num:0 is 5num:1 is 4num:2 is 3 enumerate函数会返回一对数据，分别是元素的下标和元素本身 列表-排序和倒置对原列表进行排序1234567names &#x3D; [4, 5, 3]names.reverse()print(names)names.sort()print(names)names.sort(reverse&#x3D;True)print(names) 输出:[3, 5, 4][3, 4, 5][5, 4, 3] 使用reverse函数可以直接对列表进行倒置，sort函数是升序排序的函数，如果想降序排序，sort(revers = True)即可，需要注意的是不管是sort还是reverse都没有返回值所以需要先进行排序再输出。 通过原列表排序生成新列表123names &#x3D; [4, 5, 3]print(sorted(names))print(names) 输出:[3, 4, 5][4, 5, 3] 指定不同的元素规则排序12names &#x3D; [(&#39;zhangsan&#39;, 4), (&#39;lisi&#39;, 5), (&#39;wangwu&#39;, 3)]print(sorted(names, key&#x3D;lambda n: n[1])) 输出:[(‘wangwu’, 3), (‘zhangsan’, 4), (‘lisi’, 5)] 可以通过对sorted函数里的参数进行限定来使排序按照自己设定的规则排序，如果不设定key参数那么该列表会按照第一个元素来进行排序 列表-max,min,sum1234names &#x3D; [5, 4, 3]print(max(names))print(min(names))print(sum(names)) 输出:5312 几种简单的函数可以对列表进行操作，同时需要注意的是在很多函数中只能对只有单一元素的列表进行操作，比如max，min和排序函数不能对同时包含字符串和数字的列表进行操作 列表-切片操作1234names &#x3D; [5, 4, 3, 2, 1]print(names[0:3]) #①print(names[0:3:2]) #②print(names[-1:1:-1]) #③ 输出:[5, 4, 3][5, 3][1, 2, 3] ①[0:3]代表提取列表中下标0-3的元素②[0:3:2]代表提取列表中下标0-3的元素，步数为2③[-1:1:-1]代表提取列表中-1 -1的元素步数为-1(负号的意思就是相反，-1也就是倒数第一个元素) 切片总结格式为a[start:end:step]，取子串的时候不包括end当start &gt; end时取空串空的strat和end取全部可以使用None代替空的start 列表-复制and推导式123456names &#x3D; [5, 4, 3, 2, 1]names_2 &#x3D; names[:] #①nums &#x3D; list(range(100))sq_nums &#x3D; [n*n for n in nums if n%3&#x3D;&#x3D;0] #② ①对列表切片进行复制列表②使用了一个推导式来产生新的列表，推导式的格式为[参数变化 for 参数 in 列表 if 筛选条件] 上面这个例子中使用的推导式的含义就是:用n来代表nums中每个参数并筛选出能被3整除的数，将这些数进行幂次运算得出新列表","categories":[],"tags":[{"name":"python_ds","slug":"python-ds","permalink":"https://dcher-blue.github.io/tags/python-ds/"}]},{"title":"python_list","slug":"python_6","date":"2021-02-27T14:33:54.000Z","updated":"2021-03-30T11:27:33.716Z","comments":true,"path":"2021/02/27/python_6/","link":"","permalink":"https://dcher-blue.github.io/2021/02/27/python_6/","excerpt":"","text":"列表列表的建立列表是有序的，下面是建立列表的第一种方法 12names &#x3D; [&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;]print(names) 输出:[‘zhangsan’, ‘lisi’, ‘wangwu’] 列表的建立还可以用另一种方法 1234names &#x3D; list()#创建了一个空列表names &#x3D; list(range(8))print(names) 输出:[0, 1, 2, 3, 4, 5, 6, 7] 在第二种方法中list内的参数可以是任意的iterable类参数 列表添加元素12345names &#x3D; []names.append(&#39;python&#39;)names.append(&#39;java&#39;)names.append(&#39;c++&#39;)print(names) 输出： [‘python’, ‘java’, ‘c++’]上面这个例子中通过append方法直接向列表中添加元素，这是第一种方法，在列表的结尾添加 123456names &#x3D; []names.append(&#39;python&#39;)names.append(&#39;java&#39;)names.append(&#39;c++&#39;)names.insert(2,&#39;php&#39;)print(names) 输出:[‘python’, ‘java’, ‘php’, ‘c++’]在这个例子中是使用了insert方法在列表的中间某一位置插入元素，第一个参数是插入的位置，第二个参数则是需要插入的元素 123numbers &#x3D; [&#39;5&#39;, &#39;4&#39;, &#39;3&#39;]names.append(numbers)print(names) 输出:[‘python’, ‘java’, ‘php’, ‘c++’, [‘5’, ‘4’, ‘3’]] 123numbers &#x3D; [&#39;5&#39;, &#39;4&#39;, &#39;3&#39;]names.extend(numbers)print(names) 输出:[‘python’, ‘java’, ‘php’, ‘c++’, ‘5’, ‘4’, ‘3’] 123numbers &#x3D; [&#39;5&#39;, &#39;4&#39;, &#39;3&#39;]names +&#x3D; numbersprint(names) 输出:[‘python’, ‘java’, ‘php’, ‘c++’, ‘5’, ‘4’, ‘3’] 上面这个三个例子充分说明了extend方法的作用，因为在python中可以向列表添加任意元素，所以第一个例子中使用append方法会直接向原列表中添加一个列表，第二个例子中使用了extend方法则是把新建列表的元素添加进去，第三个例子中说明列表是可以直接相加减的 列表的删除123names &#x3D; [&#39;5&#39;, &#39;4&#39;, &#39;3&#39;]del names[2]print(names) 输出:[‘5’, ‘4’]可以直接通过python自带的操作符del来按照列表下标来删除元素 1234567891011names &#x3D; [&#39;5&#39;, &#39;4&#39;, &#39;3&#39;]names.pop()print(names)numbers &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]numbers.pop(1)print(numbers)sex &#x3D; [&#39;boy&#39;, &#39;girl&#39;]s &#x3D; sex.pop(1)print(s) 输出:[‘5’, ‘4’] [‘1’, ‘3’] girl上面这个例子中使用了pop方法，第一个例子中说明了pop方法默认删除的是列表尾的元素，pop方法也可以直接按照下标来删除元素。 在第三个方法中，pop有了一个返回值s输出s以后发现正是删除的那个元素，所以pop方法和del不同，del是直接删除，而pop是将元素从列表中提取出来 123names &#x3D; [&#39;5&#39;, &#39;4&#39;, &#39;3&#39;, &#39;4&#39;]names.remove(&#39;4&#39;)print(names) 输出:[‘5’, ‘3’, ‘4’] 在上面这个例子中使用了，remove方法来按元素删除，但是需要注意的是使用remove只会删除列表中第一个符合的元素。但是如果列表没有所要删除的元素，就会报错，可以使用一段简单的代码来防止报错 12if &#39;4&#39; in names: names.remove() 这样就可以了","categories":[],"tags":[{"name":"python_ds","slug":"python-ds","permalink":"https://dcher-blue.github.io/tags/python-ds/"}]},{"title":"正则表达式_3","slug":"正则表达式-3","date":"2021-02-26T10:20:40.000Z","updated":"2021-03-01T11:19:02.986Z","comments":true,"path":"2021/02/26/正则表达式-3/","link":"","permalink":"https://dcher-blue.github.io/2021/02/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-3/","excerpt":"","text":"Python中re模块的方法search方法查找符合模式的字符，只返回第一个，返回的是一个match对象 1234import retext &#x3D; &#39;座机号码为:0451-89995006&#39;m &#x3D; re.search(r&#39;(\\d&#123;4&#125;)-(\\d&#123;8&#125;)&#39;,text) match方法返回的是一个match对象，且必须从头开始匹配和search相似 1234import retext &#x3D; &#39;ABC,WWW,ADS&#39;m &#x3D; re.match(r&#39;WWW&#39;,text) 上面这个例子返回的是None 因为match必须从头开始匹配m = re.search(r’^WWW’,text)该条语句等于用match findall方法返回所有匹配的字符串列表 12345import retext &#x3D; &#39;座机号码为:0451-89995006,0451-89995006&#39;m &#x3D; re.findall(r&#39;(\\d&#123;4&#125;)-(\\d&#123;8&#125;)&#39;,text)print(m) 上面的这个例子最后返回的结果为[(‘0451’,’89995006’),(‘0451’,’89995006’)] finditer方法返回一个迭代，其中包含所有匹配，也就是Match对象 123456import retext &#x3D; &#39;座机号码为:0451-89995006,0451-89995006&#39;it &#x3D; re.finditer(r&#39;(\\d&#123;4&#125;)-(\\d&#123;8&#125;)&#39;,text)for m in it: print(m) 返回的结果为:&lt;re.Match object; span=(6, 19), match=’0451-89995006’&gt;&lt;re.Match object; span=(20, 33), match=’0451-89995006’&gt; sub方法替换匹配的字符串，返回替换完成的文本 12345import retext &#x3D; &#39;ABC,WWW,ADS&#39;m &#x3D; re.sub(r&#39;WWW&#39;,&#39;***&#39;,text)print(m) 返回值为:ABC,***,ADS subn方法替换匹配的字符串，返回替换完成的文本和替换的次数和sub相似 但是多返回一个替换的次数 split方法用匹配表达式的字符串做分隔符分隔原字符串 123456import retext &#x3D; &#39;ABC, DSF? TQEW!WWW&#39;m &#x3D; re.split(r&#39;\\s*[,?!]\\s*&#39;,text)print(m) 返回值为:[‘ABC’, ‘DSF’, ‘TQEW’, ‘WWW’] compile方法把正则表达式编译成一个对象，方便后面使用,了解了再码","categories":[],"tags":[{"name":"python_re","slug":"python-re","permalink":"https://dcher-blue.github.io/tags/python-re/"}]},{"title":"正则表达式_2","slug":"正则表达式_2","date":"2021-02-25T12:21:22.000Z","updated":"2021-02-28T08:51:27.720Z","comments":true,"path":"2021/02/25/正则表达式_2/","link":"","permalink":"https://dcher-blue.github.io/2021/02/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_2/","excerpt":"","text":"深入了解python中的正则表达式首先要扳正之前第一篇里所写的一个问题先看一个例子 12345import retext &#x3D; &#39;这是一段文字和数字混合:123456一三五七九1579&#39;print(re.findall(r&#39;中午一三五七九&#39;,text))print(re.findall(r&#39;[中午一三五七九]&#39;,text)) 上面这个例子中两句要查找的字符串一个用了一个[]括起来另一个则没有那么[]的作用究竟是什么呢？不妨来看看这两局print的输出都是什么：[][‘一’, ‘一’, ‘三’, ‘五’, ‘七’, ‘九’]看到这个输出结果想必就明白了[]的作用了，当使用[]时代表[]中字符串任意符合即被选取出来,但是如果没有使用[]那么所查找的字符串中必须和要查找的字符串完全符合才可以被查找出，这就是[]的作用 写正则表达式的步骤1.确定包含了几个子模式2.各个子模式的字符分类是什么3.各个子模式是如何重复(或者说字符的数量)4.是否有外部位置限制5.是否有内部制约关系 以上就是书写正则表达式的五个步骤，假设要查找一个座机号:0451-89523232-9563开始分析这个座机号1.包含的子模式:&#39;0541&#39;,&#39;89523232&#39;,&#39;9563&#39;，这三个子模式用&#39;-&#39;连接2.每个子模式的字符分类：都是数字类型使用\\d3.第一个子模式是\\d&#123;4&#125;, 第二个子模式是\\d&#123;8&#125;, 第三个子模式是\\d&#123;4&#125;4.没有外部位置限制5.也没有内部制约关系这样就分析出这个正则表达式的规则了也就是’\\d{4}-\\d{8}-\\d{4}’ 语法规则语法规则——字符类别1.字符常量:abc1232.数字字符:\\d3.非数字字符:\\D4.空格:\\s5.非空格:\\S6.任意字母数字下划线字符:\\w7.除字母数字下划线字符字符：\\W8.[abcf]：代表取abcf任意字符9.[a-e]：范围：从a到e中任意一个字符10.[^a-d]：取反，除了a到d中的任意一个字符11.[\\b]：退格符号(Backspace)12. . :除了换行\\n之外的任意一个字符 语法规则——量词1.*:0或多个2.+:1或多个3.?:0或1个4.&#123;2&#125;:2个5.&#123;2,5&#125;:2到5个6.&#123;2,&#125;:至少2个7.&#123;,5&#125;:最多5个 语法规则——组合1.|:或 多种子模式满足其一即可2.():分组，比如:abc&#123;3&#125;代表abccc, (abc)&#123;2&#125;代表abcabc 语法规则——位置1.^:字符串开头2.\\A:字符串开头，忽略m标记3.&amp;:字符串行尾4.\\Z:字符串行尾，忽略m标记5.\\b:单词边界6.\\B:非单词边界7.(?=...)：匹配...出现在之后的位置8.(?!...): 匹配...不出现在之后的位置9.(?&lt;=...): 匹配...出现在之前的位置10.(?&lt;!...): 匹配...不出现在之前的位置11.(?()|): 条件语句 语法规则——分组1.(...):捕获一个组2.(?P&lt;Y&gt;...):捕获组名为Y3.(?:...):不捕获组4.\\Y:匹配第Y个匹配到的组5.(?P=Y):匹配名为Y的组6.(?#...):注释 语法规则——标记1.i:忽略大小写2.m:^和$匹配行首和行尾3.s:.匹配换行符4.x:允许空格和注释5.\\L:由当前语言区域决定 \\w, \\W, \\b, \\B和大小写敏感匹配6.\\u:Unicode匹配7.(?iLmsux):在正则表达式中设置标记 语法规则——特殊字符1.\\n:换行符2.\\r:回车符3.\\t:tab符号4.\\YYY：八进制符号YYY5.\\xYY：16进制符号YY 语法规则——替换1.\\g&lt;0&gt;:插入整段匹配2.\\g&lt;Y&gt;:插入匹配Y，Y可以是匹配的名字或者数字3.\\Y:插入名为Y的组","categories":[],"tags":[{"name":"python_re","slug":"python-re","permalink":"https://dcher-blue.github.io/tags/python-re/"}]},{"title":"python_5","slug":"python_5","date":"2021-02-23T09:14:54.000Z","updated":"2021-02-28T08:50:41.682Z","comments":true,"path":"2021/02/23/python_5/","link":"","permalink":"https://dcher-blue.github.io/2021/02/23/python_5/","excerpt":"","text":"MenuMenu组件用于实现顶级菜单，下拉菜单和弹出菜单 顶级菜单要创建一个顶级菜单，首先要创建一个菜单实例，然后使用add()方法将命令和其他子菜单添加进去 1234567891011121314151617from tkinter import *root &#x3D; Tk()menubar &#x3D; Menu(root)def copy(): print(&quot;copy&quot;)def paste(): print(&quot;paste&quot;)menubar.add_command(label&#x3D;&quot;copy&quot;,command&#x3D;copy)menubar.add_command(label&#x3D;&quot;paste&quot;,command&#x3D;paste)root.config(menuu&#x3D;menubar)root.mainloop() 如上所示建立了一个顶级菜单分别为”copy”和”paste” 选择框文本单选框用于设置某一个单选按钮为选中的状态，比如默认的情况是选中第一个定义的单选按钮，我们可以通过设置不同的value 来达成单选的目的 123456789101112from tkinter import *root &#x3D; TK()radio_1 &#x3D; Radiobutton(root, text&#x3D;&#39;Java&#39;, value&#x3D;1)radio_2 &#x3D; Radiobutton(root, text&#x3D;&#39;Python&#39;, value&#x3D;2)radio_1.pack()radio_2.pack() 这样就在root上设置了一组选项为”Java”和”Python”的单选框","categories":[],"tags":[{"name":"python_tkinter","slug":"python-tkinter","permalink":"https://dcher-blue.github.io/tags/python-tkinter/"}]},{"title":"python_4","slug":"python_4","date":"2021-02-23T07:53:31.000Z","updated":"2021-02-28T08:50:49.606Z","comments":true,"path":"2021/02/23/python_4/","link":"","permalink":"https://dcher-blue.github.io/2021/02/23/python_4/","excerpt":"","text":"文本框组件Tkinter模块中已经学习的函数再码字复习一下 Tk相当于创建了一个窗口，root = Tk() #即建立一个名为root的主窗口也就是下面各个控件的父容器 FrameFrame控件是用来在屏幕上显示一个矩形区域。格式为：a = Frame(master, option, …)1.master: 按钮的父容器2.options: 可选项，即该按钮的可设置的属性，这些选项可以用键 = 值的形式设置， 并以逗号分隔。 Entry个人的理解是文本框？，导入了Tkinter模块用Entry建立一个文本框，格式为：b = Entry(master, option, …),其中参数意义与Frame一致 ButtonButton是按钮组件，可以再Button上放文本或图像，可以与函数相关联，按下按钮时调用函数格式为： c = Button(master, option=value, …) LaberLaber控件是用以在指定的窗口中显示文本和图像，若是需要显示一行或者多行且不允许用户修改的文本，那么就可以使用Label组件了.格式为：d = Label(maser, option, …) grid控件的几何状态管理方法的一种，举个简单的例子吧a.grid(row=0, column=0,sticky=’nwes’) 意思和参数一致，需要注意的是grid是以表格的形式塞进区域中，而另一种几何管理方法pack则是直接塞进区域中。 mainloop这是一个在tkinter中用以循环这个窗口程序的方法 ##文本框组件中常用的方法 delete getdelete的几种用法：1. c.delete(10) #删除索引值为10的值2. c.delete(10,20) #删除索引值从10到20之间的值3. c.delete(0,END) #删除所有值 get方法是用以获取文件框的值 command相当于响应器，按钮中添加才可以使按钮被按时实现相应目的","categories":[],"tags":[{"name":"python_tkinter","slug":"python-tkinter","permalink":"https://dcher-blue.github.io/tags/python-tkinter/"}]},{"title":"正则表达式_1","slug":"正则表达式_1","date":"2021-02-20T10:31:49.000Z","updated":"2021-02-28T08:51:32.872Z","comments":true,"path":"2021/02/20/正则表达式_1/","link":"","permalink":"https://dcher-blue.github.io/2021/02/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_1/","excerpt":"","text":"什么是正则表达式？正则表达式是一串字符串，个人理解是自己规定的一个规则 正则表达式的简单使用在python中正则表达式需要导入的模块是re 1import re 这样就可以开始使用了首先是使用格式: 1re.match(&#39;规则&#39;,验证内容) 如上所示这是正则表达式的使用格式，具体的规则是什么样先看一个例子：要在计算器上输入一串数字，设置正则表达式规则验证输入是否合法在设置规则之前首先要明白包含了什么条件，上面例子中所包含的条件有：1.首先是+或-开头，可以有也可以没有2.包含了1个或多个数字3.可以有小数点也可以没有4.小数点后可以有0到多个数字 明确了包含的规则以后就该尝试应用了 12345678910111213141516import rea &#x3D; input()def validate_input(s): reg &#x3D; &#39;^[+-]?[\\d]+[.]?[\\d]*$&#39; r &#x3D; re.match(reg,s) return ris_valid &#x3D; validate_input(a)if(is_valid): print(&#39;yes&#39;)else: print(&#39;no&#39;) 如上所示 规则被定义成reg = ‘^[+-]?[\\d]+[.]?[\\d]$’,开始一个一个来弄清楚这些符号1.正则表达式的规则要以’^’开始,同时要以’$’结束2.用以代表不同意义的符号要用[]括起来，上面的\\d是代表数字3.？代表一个或者没有，+代表一个或者多个，代表没有或者多个 这样就弄懂简单的正则表达式的运用了。","categories":[],"tags":[{"name":"python_re","slug":"python-re","permalink":"https://dcher-blue.github.io/tags/python-re/"}]},{"title":"C_1","slug":"C-1","date":"2020-12-06T05:40:02.000Z","updated":"2021-02-26T08:55:14.501Z","comments":true,"path":"2020/12/06/C-1/","link":"","permalink":"https://dcher-blue.github.io/2020/12/06/C-1/","excerpt":"","text":"指针这次略微记下自己对C语言中指针的一些感受和体会吧 指针的定义？指针的定义很简单 只需要在你定义的变量前加一个*即可，举个例子吧：int *i;这样就定义了一个指针，*我是这样理解的，它就和int这种关键字一样只是定义指针的符号，当然也不全然如此 指针的概念&amp;&amp;初始化先说说指针的概念吧 ，一个指针变量代表什么呢，让我们先定义一个指针变量并且初始化int *p = &amp;a;,*p是代表什么呢？ 这里面*p代表的是所对应的a的值，而p代表的是指向的变量(也就是a)的地址，所以初始化的时候要用一个&amp;符号 指针的作用因为接触的属实不是很多，举个简单的例子吧： 123456789101112void f1(int *p)&#123; ... &#125;void main()&#123; int *i &#x3D; &amp;a; fi(&amp;a); ...&#125; 如图只是一个未完成的程序 不过需要的东西已经列出了，主函数main()调用了一次f1()函数,传入f1()的实参为&amp;a是一个地址，f1()用来接收的形参也是一个指针类型的变量。 废话了这么多为什么要这么写？ 因为正常情况下是无法通过在主函数中调用子函数传参，然后通过子函数改变主函数的值的，但是使用了指针变量就不一样了，传入的是变量的地址，而在主函数中改变的也是同样地址中的值，所以在子函数中改变子函数的值，当然可能这只是他的作用其一而已 但是这不妨碍用这个例子来简单的了解指针 二级指针哈哈哈首先又是一个提问，什么是二级指针？，一级指针是直接定义一个指针变量，二级指针是用另一个定义的指针变量指向原先的指针变量，当然也可以int **p;，我们先明确二级指针的意义，一级指针中存的是所指向的地址，因此二级指针就是所指向的一级指针的地址。 数组&amp;&amp;指针数组？首先让我们定义一个指针数组好了： 1int *i &#x3D; a[5]; 如上所示一个指针数组就定义完毕了，那么有一个问题为什么之前在定义指针的时候用到了取地址符&amp;而这次定义指针数组却没有呢？原来当定义一个指针指向的是一个数组的时候不管是字符串数组还是其他，指针指向的不是整个数组的全部地址(当然也不能),这时候指针指向的是该数组的首地址。","categories":[],"tags":[{"name":"C_指针","slug":"C-指针","permalink":"https://dcher-blue.github.io/tags/C-%E6%8C%87%E9%92%88/"}]},{"title":"GLCM_2","slug":"GLCM-2","date":"2020-12-04T05:54:55.000Z","updated":"2020-12-17T08:30:36.056Z","comments":true,"path":"2020/12/04/GLCM-2/","link":"","permalink":"https://dcher-blue.github.io/2020/12/04/GLCM-2/","excerpt":"","text":"GLCM衍生出的统计量灰度共生矩阵有14个特征统计量，因为我的实验中只用到了其中的六个统计量，就不赘述其他，以下为所用的统计量1.contrast(对比度)2.dissimilarity(差异性)3.homogen eity(同质性)4.energy(能量)5.correlation(相关性)6.ASM(ASM能量) contrast(对比度)对比度直接反映了某个像素值以及该领域像素值的亮度对比情况。若是偏离对角线的元素有较大值，即图像值变化很快，则对比度就会有较大的取值。其中反应了图像的清晰度和纹理沟纹深浅的程度，举个例子：纹理沟纹越深，其对比度就越大，视觉效果越清晰。反之，对比度小，则沟纹浅，效果模糊灰度差即对比度大的像素对越多，这个值越大。灰度共生矩阵中远离对角线的元素值越大，对比度也就越大 ASM(ASM能量)如果灰度共生矩阵中的值集中在了一起(比如对连续灰度值图像，值集中在偏离对角线的位置),那么ASM有较大，若G中的值分布较均匀(比如噪声严重的图像),则ASM有较小的值如果共生矩阵的所有值均相等，则ASM值小。如果其中一些值大而其他值小，则ASM值大，如果共生矩阵中元素集中分布时，ASM值大ASM值大表明一种较均一和规则变化的纹理模式 correlation(相关性)相关性反应了图像纹理的一致性，如果图像中有水平方向纹理，则水平方向矩阵的相关性大于其余矩阵相关性的值。相关性用以度量空间灰度共生矩阵元素在行或列方向上的相似程度，因此，相关值大小反映了图像中局部灰度相关性。当矩阵元素值均匀相等时，相关值就大，如果矩阵元素值相差大那么相关值小 energy(能量)能量就是灰度共生矩阵元素值的平方和，能量也反映了图像的清晰度和纹理沟纹 坏起来了 剩下的两周之内在最后分类器做完以后再编辑了","categories":[],"tags":[{"name":"GlCM","slug":"GlCM","permalink":"https://dcher-blue.github.io/tags/GlCM/"}]},{"title":"GLCM_1","slug":"GLCM_1","date":"2020-12-01T14:12:53.000Z","updated":"2021-03-30T11:33:10.892Z","comments":true,"path":"2020/12/01/GLCM_1/","link":"","permalink":"https://dcher-blue.github.io/2020/12/01/GLCM_1/","excerpt":"","text":"灰度共生矩阵-GLCM哈哈哈哈哈怎么有奇奇怪怪的东西加入了博客里，没办法这也是学习的一部分先说说什么是灰度共生矩阵吧，灰度共生矩阵是用来对图像做纹理特征提取的一种统计分析方法他的历史就不说了哈哈哈哈还是主要了解用法和代码实现 概念通过计算灰度图像得到它的共生矩阵，然后再计算所得到的共生矩阵的部分特征值，来分别代表图像的某些纹理特征。灰度共生矩阵能反映图像灰度关于方向、相邻间隔、变化幅度等综合信息，它是分析图像的局部模式和它们排列规则的基础。`取图像(N×N)中任意一点 （x，y）及偏离它的另一点 （x+a，y+b），设该点对的灰度值为 （g1，g2）。令点（x，y） 在整个画面上移动，则会得到各种 （g1，g2）值，设灰度值的级数为 k，则（g1，g2） 的组合共有 k 的平方种。对于整个画面，统计出每一种 （g1，g2）值出现的次数，然后排列成一个方阵，再用（g1，g2） 出现的总次数将它们归一化为出现的概率P（g1，g2） ，这样的方阵称为灰度共生矩阵。距离差分值（a，b） 取不同的数值组合，可以得到不同情况下的联合概率矩阵。（a，b） 取值要根据纹理周期分布的特性来选择，对于较细的纹理，选取（1，0）、（1，1）、（2，0）等小的差分值。当 a=1，b=0时，像素对是水平的，即0度扫描；当a=0，b=1 时，像素对是垂直的，即90度扫描；当 a=1，b=1时，像素对是右对角线的，即45度扫描；当 a=-1，b=1时，像素对是左对角线，即135度扫描。 `。。。。看起来实际上还是有些深奥，直接看概念来理解真的很难，下面来通过例子理解 实例理解GLCM了解灰度共生矩阵之前要先清楚几个参数的概念：1.步距d:选择的像素点与偏离它的另一点的距离，一般d取12.方向：两个像素点的空间上的方向，一般只选取0°，45°，90°，135°3.滑动窗口尺寸：以计算的像素点为中心，取出的待计算矩阵的大小，一般选取3*3，5*5，7*74.灰度阶数：像素灰度值大小，一般有256，126，64，32等 好了知道了这几个参数以后就来看看实例吧假设有一副图像，我们得到其中的一个像素点的灰度共生矩阵，计算纹理特征值，大小为6*6，灰度被分为4阶(0,1,2,3),如下第一种方向：d=1,方向=0° 如图选取元素最终得到共生矩阵为: 其他三种方向就是根据角度的不同做出改变啦就不一一举例了 特征值计算得到了图像上每个像素点的共生矩阵以后，可以计算出很多种特征值来表示其纹理特性，哈哈哈实验种用到了角二阶矩（能量），对比度，相关度，熵，其他就不说了！ 滑动窗口的实现通过上文我们可以知道，每个像素点都会有其自身的一个共生矩阵，而我们需要得到整幅图的一个完整特征矩阵来用作纹理分析、模型特征向量输入等。通过对3×3、5×5窗口的滑动，可以得到整幅图像的完整结果。上文举例的是一个滑动窗口，每个滑动窗口都可以计算得到一个特征值（能量、对比度等）。完成一个像素点的计算后，再将中心像素点移动到下一个，再形成一个滑动窗口后重复上一步的计算，遍历完全部的像素点后，就生成了一个由纹理特征值构成的一个纹理特征值矩阵，这个矩阵的维度即原始图像的维度，每个点的值就是原始图像上该点对应的像素点的灰度特征矩阵特征值。","categories":[],"tags":[{"name":"python_GLCM","slug":"python-GLCM","permalink":"https://dcher-blue.github.io/tags/python-GLCM/"}]},{"title":"VS CODE_","slug":"VS-CODE","date":"2020-12-01T07:39:59.000Z","updated":"2021-03-22T02:39:44.401Z","comments":true,"path":"2020/12/01/VS-CODE/","link":"","permalink":"https://dcher-blue.github.io/2020/12/01/VS-CODE/","excerpt":"","text":"关于为什么使用VS CODE？在还没有接触VS CODE的时候不论是在学习JAVA还是python的过程中使用的工具都是JetBrains公司的开发的工具，哈哈哈哈买不了只能用阉割版而且很麻烦！没有中文 一直都有点苦恼来着 直到今天了解了VS CODE！！就是这个图标！ VS CODE的优点？？因为是刚刚接触所以可能知道的不是很多了！最最显而易见的优点完全免费hhhh的确是一个不错的地方，除此之外还有支持中文,看见别人说其实VSCODE也很占用内存。不过对于我这种初学者来说很好用了！可以限定工作区开启不同的插件，相比pycharm来说占用的内存少很多了而且还有一个优点是启动快，使用pycharm的时候真的是超级超级慢，开一次要等好久，但是vscode几乎一点就开(?)嗯就这么多吧！以后了解的多了随时回来补充.jpg 关于vs code中的一些设置说到设置就不得不提语言设置里的支持中文了，中文真的很亲切啊！(咳咳也有可能是我这种丈育学习者对于英语没有那么了解啦233)说了那么多废话就来康康怎么设置的中文8首先点开vscode 使用快捷键ctrl``+``shift``+``p 然后在搜索框中键入language点击选择如图所示，然后显示的就是当前软件拥有的语言，不过默认只有en所以选安装其他语言选择你需要的语言就可以了！ 嘿嘿很简单吧 debug的调试在之前的学习中一直都没有接触过这个都是之间看error找错误…..今天接触了一下vscode中的debug调试感觉意外的好用？ 不过目前接触来看好像这个功能设置断点并不能查出Error？只是来查出为什么没有显示出原本应该出来的结果？哈哈哈哈说的好像有点乱 举个栗子吧 如下所示： 可能看起来还是有些不清晰，简单说说首先要设置断点，这个断点可以随意的设置在代码段的任何地方可以是一个也可以是多个然后按F5或者点工具栏的运行→启动调试进入如下界面在其中选择你需要调试的文件类型，一般来说第一个默认为当前文件类型点击后进入调试模式首先左边显示的是各种变量用于观察程序执行的流程然后使用debug调试生成的工具栏开始调试共有六个按键，在这里分别说一下功能1.开始每轮的debug调试，遇到断点即停止本次调试2.单步运行debug调试3.用以单独进入程序段中某个函数4.用以单独跳出程序段中某个函数5.重 启6.终止debug调试 然后开始运行上面gif中的内容，既然要查出哪里出现了问题那么肯定要选取关键的调试值先选取3 5 15 在3 5调试的过程中没出现问题，但是到了15这里我们发现遇到第一个if判断语句以后直接判断完毕，所以这里出现的问题是语句的不严谨(?)可以把elif(i % 15 == 0)这条语句放到最上面即可","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://dcher-blue.github.io/tags/tool/"}]},{"title":"python_3","slug":"python_3","date":"2020-11-30T14:19:53.000Z","updated":"2021-03-01T11:18:50.746Z","comments":true,"path":"2020/11/30/python_3/","link":"","permalink":"https://dcher-blue.github.io/2020/11/30/python_3/","excerpt":"","text":"有关于global通常情况下局部变量就是局部变量，一般无法通过改变局部变量来改变全局变量还是举个栗子8 12345678count &#x3D; 8def f1(): global count count &#x3D; 10 print(count)work()print(count) 上面这个栗子最后会输出什么呢？没错没错没错，最后输出的是两个10 因为在F1()函数内通过global将count生效范围变成了全局 有关变量的小知识1.全局变量的作用范围仅限于当前文件2.可以通过以下方式调用别的文件的全局变量 123import 文件名print(文件名.变量名) 3.另一文件的局部变量无法通过任何方式访问4.全局变量可以直接在函数内调用，甚至无需传参5.如果在函数内声明一个同名于全局变量的局部变量，那么在函数内该变量的作用范围变为局部 如何判断列表是否为空？1.可以通过len()函数！具体函数的内容会有新的一个标签？2.直接 if 列表名 即可判断是否为空","categories":[],"tags":[{"name":"python_var","slug":"python-var","permalink":"https://dcher-blue.github.io/tags/python-var/"}]},{"title":"python_1","slug":"python_1","date":"2020-11-29T07:54:24.000Z","updated":"2021-03-01T11:18:30.988Z","comments":true,"path":"2020/11/29/python_1/","link":"","permalink":"https://dcher-blue.github.io/2020/11/29/python_1/","excerpt":"","text":"关于python中函数的参数python中函数的参数有很多都和其他语言相似但是也有一点不同的。1.位置/强制位置参数2.关键词/强制关键词参数3.可变参数(位置or关键词) 位置/强制位置参数位置参数：就是按位置传参,按照调用函数所传参数的顺序传给函数 123def f1(a,b,c): printf(a*a+b*c+c)f1(5,6,7) 强制位置参数:用反斜杠‘/’来使强制位置参数生效，如下，凡是在/以前的参数一定要是位置参数 123def f(a, b, &#x2F;, c, d, *, e, f, **kwargs): print(a, b, c, d, e, f, kwargs[&#39;s1&#39;], kwargs[&#39;s2&#39;])f(3,4,5,6, e&#x3D;7, f&#x3D;8, s1&#x3D;&#39;85&#39;, s2&#x3D;&#39;516&#39;) 关键词/强制关键词参数关键词参数：可以完全不考虑位置，只看对应的关键词来传参 123def f1(a,b,c): printf(a*a+b*c+c)f1(c&#x3D;5,b&#x3D;7,a&#x3D;3) 强制关键词参数:用‘’来使强制关键词参数生效，如下，凡是在以后的参数必须强制是关键词参数 123def f1(*,a,b,c):#*后面的参数必须强制是关键字参数前面则无需 print(a*a + 2*b + c)f1(a&#x3D;3,b&#x3D;5,c&#x3D;8) 可变参数(位置or关键词)可变位置参数：和位置参数最大的不同就是可变位置参数以后无需在函数里多设置形参，可以直接传实参 1234def hello(msg,*names):#如若混搭,一定要先固定参数，再可变参数 print(&quot;hello&quot;,names, msg) #所传参数会被合并成一个元组,也可以一个不传hello(&#39;xinnianhao&#39;,&#39;zhangsan&#39;,&#39;lisi&#39;)#若是要破开所传参数合并成的元组 #只需print(&quot;hello&quot;,*names, msg)即可 可变关键词参数：同样的可变参数以后无需多设置形参直接传实参即刻，但是注意传实参必须用键值对的形式！ 1234def hello(msg,**names):#调用必须用键值对调用如：&quot;boss&#x3D;&#39;zhangsan&#39;&quot; print(&#39;老大是&#39;, names[&#39;BOSS&#39;]， msg)#也要先固定后可变 print(&#39;老二是&#39;, names[&#39;BOSS2&#39;]， msg)hello(&#39;新年好&#39;, BOSS&#x3D;&#39;zhangsan&#39;, BOSS2&#x3D;&#39;LISI&#39;, GUARD&#x3D;&#39;WANGWU&#39;) 参数的优先级如果各种参数混搭，那么他们的优先级顺序为： 必选参数＞默认参数＞可变位置参数＞命名关键字参数＞可变关键字参数 举个简单的例子： 123456def f(a, b, c, d, *arg, e, f, **kwargs):#其中e , f为命名关键词参数 print(a, b, c, d, e, f) print(args) print(kwargs)f(1,2,3,4,5,99,e&#x3D;6,f&#x3D;7,x&#x3D;8) 列表元组字典的开包列表元组的开包：无论是元组还是列表，传参在参数前加上*即可直接打开数组或元组 12345def hello(msg, name1, name2, name3): print(&#39;hello&#39;, name1, name2, name3, msg)names &#x3D; [&#39;zhangsan&#39;,&#39;lisi&#39;,&#39;wangwu&#39;]hello(&#39;您好&#39;, *names)#传参加入*直接打开数组或者元组 字典的开包：同样的，字典的开包和元组列表相似 1234567def hello(msg,**names): print(&#39;老大是&#39;, names[&#39;BOSS&#39;]， msg) print(&#39;老二是&#39;, names[&#39;BOSS2&#39;]， msg)data &#x3D; &#123;&#39;BOSS&#39;:&#39;zhangsan&#39;, &#39;BOSS2&#39;:&#39;LISI&#39;, &#39;GUARD&#39;:&#39;WANGWU&#39;&#125;# hello(&#39;新年好&#39;,BOSS&#x3D;&#39;zhangsan&#39;, BOSS2&#x3D;&#39;LISI&#39;, GUARD&#x3D;&#39;WANGWU&#39;)hello(&#39;新年好&#39;,**data) 可变数组元组的开包:在上面已经学到了，形参前有*时变成可变参数，同时传入的是一个元组，开包方式如下 1234567# def hello(msg, *names):#这里的*代表的是可变元组or数组# print(&#39;hello&#39;, names, msg)# names_s &#x3D; [&#39;zhangsan&#39;,&#39;lisi&#39;,&#39;wangwu&#39;]# hello(&#39;您好&#39;, *names_s) #首先在调用hello时将names元组or数组开包 #然后传入函数hello再合并成元or数组 #最后打印的时候再次打开该元组or数组","categories":[],"tags":[{"name":"python_parameter","slug":"python-parameter","permalink":"https://dcher-blue.github.io/tags/python-parameter/"}]},{"title":"python_2","slug":"python_2","date":"2020-11-28T16:00:00.000Z","updated":"2021-03-01T11:18:29.938Z","comments":true,"path":"2020/11/29/python_2/","link":"","permalink":"https://dcher-blue.github.io/2020/11/29/python_2/","excerpt":"","text":"匿名函数—-lambda匿名函数的特点：1.没有名称的一行函数，大部分是一次性函数2.不用def声明，也可以被复制,传参 举个简单的例子：如下所示，定义了一个函数并传入了一个列表，如果想要改变并多输出一次该函数，有很多方法，最简单的就是ctrl+c,ctrl+v再来一次改改内容但是会占用很多代码行而且看起来很臃肿，这时候匿名函数就起到了作用， 123456789101112numbers &#x3D; [2, 4, 6, 8 ,5 ,3 ,11]def process(numbers,yeah): for n in numbers: print(yeah(n), end&#x3D;&#39; &#39;) print()process(numbers, lambda x:15 if x%3&#x3D;&#x3D;0 else x)process(numbers, lambda x:x+3 )process(numbers, lambda x:x*x ) 局部变量local和全局变量glocal 其实也没什么好说的Python中的局部变量全局变量和C相似局部变量是在def定义的函数或者calss定义的类内的变量全局变量则是在脚本内(def和class之外)定义的变量。 name == ‘main‘这行代码很有意思 __name__这个变量是python在调用一个脚本的时候自动创建并分配这个变量的值。但是有两种分配方法__name__我们可以直接用它，如果直接调用__name__所在脚本直接调用，那么会直接打印它，但是如果是别的模块引入这个文件，那么分配的值就是文件的名字, 123print(__name__)def f1(): print(&#39;yeah!&#39;) 12import test1test1.f1() 如上所示有两个文件第一个为文件’test1.py’ 第二个为文件’test2.py’当运行’test1.py’时 结果为”main“当运行’test2.pt’时 结果为”test1 yeah!”其中’test1’为所运行脚本的名字 他的作用有很多，其中之一如下：还是上面两个文件 123def f1(): print(&#39;yeah!&#39;)f1() 12import test1test1.f1() 如上所示，当’test2.py’调用f1()时 会多打印一次因为’test1.py’本身调用了一次这时候就要用到了上面所讲的__name__了只需给文件1中的调用附加一个if语句即可 12if __name__ &#x3D;&#x3D; &#39;__main__&#39;: f1() 这时就不会发生调用另一文件的函数出现多次调用的情况了。或许能在很多地方用到！用到了回来补充orz doc这也是一个很实用的变量他的作用是用程序来生成一个文档 同样举个栗子： 12345def oh(): &quot;&quot;&quot;这是一个学习用的函数，具体作用是来解释__doc__变量 这个栗子举完应该就很清晰了！ &quot;&quot;&quot;print(oh.__doc__) 这时候调用oh()函数就会显示三引号里面的东西啦！","categories":[],"tags":[{"name":"python_def","slug":"python-def","permalink":"https://dcher-blue.github.io/tags/python-def/"}]}],"categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://dcher-blue.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"python_def","slug":"python-def","permalink":"https://dcher-blue.github.io/tags/python-def/"},{"name":"pygame","slug":"pygame","permalink":"https://dcher-blue.github.io/tags/pygame/"},{"name":"python_ds","slug":"python-ds","permalink":"https://dcher-blue.github.io/tags/python-ds/"},{"name":"python_re","slug":"python-re","permalink":"https://dcher-blue.github.io/tags/python-re/"},{"name":"python_tkinter","slug":"python-tkinter","permalink":"https://dcher-blue.github.io/tags/python-tkinter/"},{"name":"C_指针","slug":"C-指针","permalink":"https://dcher-blue.github.io/tags/C-%E6%8C%87%E9%92%88/"},{"name":"GlCM","slug":"GlCM","permalink":"https://dcher-blue.github.io/tags/GlCM/"},{"name":"python_GLCM","slug":"python-GLCM","permalink":"https://dcher-blue.github.io/tags/python-GLCM/"},{"name":"tool","slug":"tool","permalink":"https://dcher-blue.github.io/tags/tool/"},{"name":"python_var","slug":"python-var","permalink":"https://dcher-blue.github.io/tags/python-var/"},{"name":"python_parameter","slug":"python-parameter","permalink":"https://dcher-blue.github.io/tags/python-parameter/"}]}